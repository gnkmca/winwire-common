package com.winwire.adobe.jdbc

import com.winwire.adobe.utils.Using

import java.sql.{CallableStatement, Connection, Ref, ResultSet, SQLType, Statement, Types}
import scala.util.{Failure, Success, Try}
import org.apache.commons.dbcp.BasicDataSource

private[jdbc] object JdbcConnector {

  case class ConnectionManager(connections: Set[ConnectionDetails],
                               initPoolSize: Int = 2,
                               maxPoolSize: Int = 5
                              ) extends AutoCloseable with Using {

    val dataSources: Map[String, BasicDataSource] = connections.map(c => (c.db, createDataSource(c))).toMap

    def getConnectionTo(con: ConnectionDetails): Connection = dataSources(con.db).getConnection

    def withConnectionTo(con: ConnectionDetails): JdbcConnection = JdbcConnection(this.getConnectionTo(con))

    override def close(): Unit = dataSources.foreach(t => releaseSilently(t._2)(res => res.close()))

    def createDataSource(con: ConnectionDetails): BasicDataSource = {
      val ds = new BasicDataSource()
      ds.setDriverClassName(con.driver)
      ds.setUrl(con.url)
      ds.setUsername(con.user)
      ds.setPassword(con.pass)
      ds.setDefaultAutoCommit(true)
      ds.setInitialSize(initPoolSize)
      ds.setMaxActive(maxPoolSize)
      ds
    }
  }

  case class JdbcConnection(connection: Connection) extends Using {

    def sql[RES](query: String)(transform: ResultSet => RES): Seq[RES] = {
      using(connection) { con =>
        val statement = con.createStatement()
        using(statement) { st =>
          val resultSet = st.executeQuery(query)
          using(resultSet) { rs =>
            val result = results(rs)(transform)
            result
          }
        }
      }

    }

    def sqlUpdate(query: String, returnAutoGeneratedKey: Boolean): Option[Long] = {
      using(connection) { con =>
        val statement = if (returnAutoGeneratedKey) {
          con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS)
        } else {
          con.prepareStatement(query)
        }
        using(statement) { st =>
          Try(st.executeUpdate()) match {
            case Success(affectedRecords) =>
              if (returnAutoGeneratedKey) {
                val afs = st.getGeneratedKeys
                Try(if (afs.next) afs.getLong(1) else 0).toOption
              } else {
                Some(affectedRecords)
              }
            case Failure(e) =>
              logger.error("Was unable to process SQL query", e)
              None
          }
        }
      }
    }

    /**
     * Execute Stored Procedure with Input Parameters
     *
     * @param query
     * @param inputParams
     */
    def executeStoredProcedure(query: String, inputParams: Map[String,String], outputParams: Map[String,Int]): CallableStatement = {
      val statement = connection.prepareCall(query,
        ResultSet.TYPE_SCROLL_INSENSITIVE,
        ResultSet.CONCUR_READ_ONLY
      )
      inputParams.foreach { case (name, value) => statement.setString(name, value) }
      outputParams.foreach { case (name, dataType) => statement.registerOutParameter(name, dataType) }
      execute(statement)
      statement
    }

    /**
     * Execute Callable Statement
     * @param statement
     */
    private def execute(statement: CallableStatement) = {
      Try {
        statement.execute()
      } match {
        case Success(s) => {
          logger.info("************ successfully executed ***********" + statement)
        }
        case Failure(ex) => {
          logger.error("************* error while executing ************" + statement)
          throw ex
        }
      }
    }

    def results[T](resultSet: ResultSet)(f: ResultSet => T): List[T] = {
      new Iterator[T] {
        def hasNext: Boolean = resultSet.next()

        def next(): T = f(resultSet)
      }.toList
    }
  }
}
